{
  "hash": "7c058389b04ede0201f0c907df17eb29",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Greenspace exposure: Finding nearby parks and distance to nearest park'\nauthor: Silvia CanelÃ³n\ndate: '2024-12-04'\nimage: featured.png\ncategories:\n  - R\n  - tutorial\n  - greenspace\n  - maps\n  - rspatial\n  - sf\n  - mapview\nsubtitle: >\n  An R tutorial on finding nearby vector polygons using spatial tools.\ndescription: '' # Text that shows below the tags, not on listing page\nlinks:\n- icon: pin-map-fill\n  name: Collection of maps\n  url: /project/2024-06-16-ccd-sips\nexecute: \n  eval: false\n---\n\n\n\n\n\n## Notes\n\n- [GitHub - ivelasq/leaidr: An R Package for U.S. School District Shapefiles](https://github.com/ivelasq/leaidr) -- school district shape files\n- [9 Walkthrough 3: Using school-level aggregate data to illuminate educational inequities | Data Science in Education Using R](https://datascienceineducation.com/c09#data-sources-2) - data sources for aggregate datasets related to education\n- [GitHub - data-edu/dataedu: An R package associated with the Data Science in Education Using R book](https://github.com/data-edu/dataedu) - Data Edu package\n- [Schools Parcels - OpenDataPhilly](https://opendataphilly.org/datasets/schools-parcels/)\n- [Schools - OpenDataPhilly](https://opendataphilly.org/datasets/schools/)\n- [PPR Tree Canopy - OpenDataPhilly](https://opendataphilly.org/datasets/ppr-tree-canopy/)\n- [OSF | PAD-US-AR](https://osf.io/pwdsg/)\n- Research:\n  - [Urban Greenspaces: Bridging Mental Health Disparities | US Forest Service Research and Development](https://research.fs.usda.gov/nrs/projects/urbangreenspaces#research) - \"Researchers found that higher levels of residential tree cover, particularly within a 250-meter radius of an individuals' home, were associated with significantly better mental health. \"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Wrangling\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# renaming variables ---\nschools <- schools |> \n  janitor::clean_names() |> \n  rename(school_id = objectid) |> \n  select(school_id, school_name_label, \n         school_address = street_address, zip_code, \n         grade_level, grade_org, enrollment, \n         type, type_specific, geometry)\n\nparks <- parks |> \n  janitor::clean_names() |> \n  rename(park_id = objectid) |> \n  select(park_id, public_name, \n         park_address = address_brt,\n         property_classification, geometry)\n  \n# CRS projections ----\nphilly <- philly |> st_transform(crs = \"EPSG:6564\")\nschools <- schools |> st_transform(crs = \"EPSG:6564\")\nparks <- parks |> st_transform(crs = \"EPSG:6564\")\n```\n:::\n\n\n\n\n## Number of nearby parks\n\n- counting unique parks. so if there are 3 unique parks nested within a \"parent\" park, all 3 are counted\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find parks within a specific buffer size in meters ----\n\nbuffer_size <- 250 # meters\n\nnearby_parks <-\n  st_join(x = schools,\n          y = parks,\n          join = st_is_within_distance,\n          dist = buffer_size)\n\n# count number of parks within a specific buffer size in meters ----\n\nschools_with_nearby_parks <-\n  nearby_parks |> \n  group_by(school_id) |> \n  mutate(number_parks = if_else(\n    !is.na(park_id),\n    n_distinct(park_id),\n    0)) |> \n  ungroup() |> \n  mutate(\n    number_parks_binary = if_else(\n      number_parks == 0,\n      \"No\",\n      \"Yes\"),\n    number_parks_binary = fct(\n      number_parks_binary,\n      levels = c(\"No\", \"Yes\"))\n    ) |> \n  # one record per school\n  select(c(school_id:type_specific, \n         number_parks, number_parks_binary)) |> \n  distinct()\n```\n:::\n\n\n\n\n## Distance to nearest park\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_schools <- schools |> head(3)\ntest_parks <- parks |> head(5)\n\n# for each school, find index of nearest park (e.g. 1 5 1)\nnearest <- st_nearest_feature(test_schools, test_parks)\n\n# create park subset from the nearest park indices\ntest2 <- test_parks[st_nearest_feature(test_schools, test_parks),]\n# test3 <- test_parks |> filter(row_number() %in% nearest)\n\n# combine the school dataset with the park subset\n# using mutate with a dataframe skips the y variables \n# that are already in x\n# mutate creates new columns from y\ntest4 <- test_schools |> mutate(test2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Distance to nearest park --------------------------------------\n \n# find closest park to school (using indexes)\nnearest_park <- schools |>\n  mutate(parks[st_nearest_feature(schools, parks),])\n\n# find distance to closest park\nnearest_park_distance <- nearest_park |> \n  mutate(distance = st_distance(schools, nearest_park, \n                                by_element = TRUE))\n\n# join back with school info\nschools_with_parks <-\n  schools_with_nearby_parks |>\n  # add distance to park variable\n  mutate(distance_to_nearest_park = \n           as.numeric(nearest_park_distance$distance),\n         .before = geometry) |> \n  # if school is 0m from nearest park, adjust to 1m\n  mutate(\n    distance_to_nearest_park = if_else(\n      distance_to_nearest_park == 0, \n      1, \n      distance_to_nearest_park),\n    .before = geometry)\n```\n:::\n\n\n\n\n## Summary\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschools_with_parks |> \n  st_drop_geometry() |> \n  gtsummary::tbl_summary(\n    include = c(number_parks, \n                number_parks_binary, \n                distance_to_nearest_park),\n    by = type,\n    type = list(\n      c(number_parks, distance_to_nearest_park) ~ \"continuous2\"\n    ),\n    statistic = list(\n      c(number_parks, distance_to_nearest_park) ~ c(\n        \"{mean} ({sd})\",\n        \"{median} ({min}, {max})\")\n    )\n  ) |> \n  gtsummary::add_overall() |> \n  gtsummary::add_p()\n\nsummary(schools_with_parks$number_parks)\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}